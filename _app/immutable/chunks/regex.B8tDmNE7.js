import{s as Dn,n as un}from"./scheduler.aZkp7-Oh.js";import{S as Fn,i as jn,e,s as p,H as On,d as o,g as c,b as l,n as Nn,o as Wn,k as a,f as Vn,h as t}from"./index.BAB4piQm.js";function Kn(En){let i,rn=`Having worked on a website for Hashbot, a Discord bot that aims to ban impersonators
using RegEx, I‚Äôve always been a bit interested improving the efficiency of one of the features: Fuzzy Matching.`,q,u,kn="The Problem",E,r,hn="Fuzzy matching, in this context means to match non-exact strings together. For example, If we have a huge Web3 server with an owner named <code>astro</code>, we may create a filter <code>(?i)^astro$</code> to ban users with names like <code>astro</code> and <code>Astro</code>. But realistically, it‚Äôd be great if we could also ban names clearly similar, such as <code>aStrO</code>, <code>a5tr0</code>, <code>Astro</code>, <code>@str0</code>, etc.",B,k,dn='For a character like <code>a</code>, characters like <code>@</code>, <code>–∞</code> (this is NOT the same - its a cryllic a.. can you tell?) are called confusables. Unicode keeps a <a href="https://www.unicode.org/Public/security/latest/confusables.txt" rel="nofollow">list</a> of them up to date. Banning everyone like that may be a strict filter, but it‚Äôs better than having users in your server losing their crypto/NFTs permanently.',D,h,fn="The Approach",F,d,mn="An initial thought may be to use something distance related like Levenshtein Distance or Hamming Distance. However, this will work poorly without significant changes, as <code>astro</code> and its visibily equivalent Cryllic partner will not have a close distance at all. They may <em>look</em> the same, but the characters are completely different!",j,f,wn="Ideally, I would like to make the change in the frontend (parser) instead of the backend, so that we can fully rely and trust the battle-scarred and tested engines to do the heavy lifting and optimize the expression on my behalf.",O,m,bn="With RegEx, we can generate filters for each confusable. However, as one can imagine, the na√Øve implementation ends up with a lot of filters when we consider all confusables <code>a</code>, <code>@</code>, <code>A</code> that match with each <code>[azAZ]</code>, especially for large servers with tons of users. Of course, we can do something like changing every <code>a</code> to <code>[a|A|@|...]</code>, but we end up with really long strings where we first have to modify the string, before having the parser parse the same thing again. Knowing that, it would be great to have:",N,w,yn="<li>some kind of SIMD RegEx where we can feed in a bunch of names and get results back quickly.</li> <li>some kind of optimization within the engine that checks alternations in O(1) time for more memory.</li> <li>most importantly, other people looking at the changes should be confident that the changes solve the problem. The code should be easily understandable to others without as much context as me, and tests should remain passing.</li>",W,b,gn="Shopping for a Solution",V,y,xn="Hyperscan?",K,g,vn='The first place that I looked at was <a href="https://github.com/intel/hyperscan" rel="nofollow">intel/hyperscan</a>, the go-to standard for heavy RegEx applications (or so I heard). Used for DPI (Deep Packet Inspection) stacks, it has lots of <a href="https://www.usenix.org/sites/default/files/conference/protected-files/nsdi19_slides_wang_xiang.pdf" rel="nofollow">whistles &amp; bells</a> including efficient SIMD processing, but only runs on Intel x86 processors. In short, Hyperscan works by compiling expressions into a immutable database using the <a href="https://www.intel.com/content/www/us/en/collections/libraries/hyperscan/regular-expression-match.html" rel="nofollow">most optimal engine</a> for that expression, then accepting strings via its C API to match strings.',Z,x,Cn="Hyperscan is great for standard applications, but isn‚Äôt a great fit here because:",$,v,Hn="<li>We permit users to add/remove expressions on the fly, so precompiling isn‚Äôt ideal.</li> <li>The parser requires <code>position</code> information at the Component level, which is not ideal. This is because we are going to ‚Äòbloat‚Äô the regex with confusables, which would make positions inaccurate. (e.g. <code>astro</code> could become <code>[a|A|@\\..]stro</code>, but parsed into an AST tree).</li> <li>The code was hard to comprehend at first glance (‚Ä¶ compared to the next option).</li>",G,C,_n="Rust‚Äôs RegEx Crate",J,H,Ln='I then looked into Rust‚Äôs RegEx crate. I‚Äôve always wanted to have an excuse to work on something in Rust, and this was the perfect chance. <a href="https://github.com/rust-lang/regex" rel="nofollow">rust-lang/regex</a> was recently rewritten to use modern methods as well, including SIMD processing. The codebase is also a lot more well documented and easier to understand than Hyperscan, with plenty of comments that explain what each line of code is doing.',Q,_,Tn='The crate is separated into <a href="https://github.com/rust-lang/regex/tree/master/regex-automata" rel="nofollow">regex-automata</a> and <a href="https://github.com/rust-lang/regex/tree/master/regex-syntax" rel="nofollow">regex-syntax</a>. The former contains the implementation for the regex engines, and the latter contains the frontend (parser) for expressions, converting expressions to AST, then to its high level intermediate representation (HIR).',X,L,Mn=`Looking into the implementation of <code>regex-automata</code>, the <code>meta</code> regex <a href="https://docs.rs/regex-automata/latest/regex_automata/#should-i-be-using-this-crate" rel="nofollow">selects the best
strategies</a> for each given expression. With the action plan being to replace the alphabets with large alternations, the strategy also being able to short-circuit <a href="https://github.com/rust-lang/regex/blob/ab88aa5c6824ebe7c4b4c72fe5191681783b3a68/regex-automata/src/meta/strategy.rs#L122" rel="nofollow">huge alternations with Aho-Corasick</a> was also a great sign.`,Y,T,In="The Solution",nn,M,Pn='All of this meant that  I can focus on modifying the <code>regex-syntax</code> crate to get what I wanted. Since I already know that I just want to replace each alphabet (literal) with a large alternation, I can just modify the parser to do that whenever it generates a new <code>Literal</code> component for the tree at the <a href="https://github.com/rust-lang/regex/blob/ab88aa5c6824ebe7c4b4c72fe5191681783b3a68/regex-syntax/src/hir/mod.rs#L342" rel="nofollow">constructor</a>. Since they all end up as some <a href="https://github.com/rust-lang/regex/blob/ab88aa5c6824ebe7c4b4c72fe5191681783b3a68/regex-syntax/src/hir/mod.rs#L593" rel="nofollow">ClassUnicode objects</a> in the end after being flattened and optimized, we can just replace the Literal object with a set of ClassUnicodes that are already implemented.',sn,I,Rn="This sounds a little complex, but it actually isn‚Äôt that hard when you get into it! The comments written at length in the implementation of <code>regex-syntax</code> comes in really handy with understanding the code.",an,P,An="An implementation could look like this:",tn,R,en,Bn=`<code class="language-rust"><span class="token comment">/*
    New struct for confusables, could have concurrent accesses.
    Mapping each possible alphabet (azAZ) with a set of confusables.
*/</span>
<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">HirConfusables</span> <span class="token punctuation">&#123;</span>
    confusables<span class="token punctuation">:</span>
        <span class="token class-name">RwLock</span><span class="token operator">&lt;</span><span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">ClassUnicodeRange</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">impl</span> <span class="token class-name">HirConfusables</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">HirConfusables</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">HirConfusables</span> <span class="token punctuation">&#123;</span> confusables<span class="token punctuation">:</span> <span class="token class-name">RwLock</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/// Add confusable characters to the map.</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">add_confusables</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token keyword">char</span><span class="token punctuation">,</span> confusables<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">let</span> <span class="token keyword">mut</span> confusables_map <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>confusables<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> <span class="token punctuation">(</span>confusables_set<span class="token punctuation">,</span> ranges<span class="token punctuation">)</span> <span class="token operator">=</span>
            confusables_map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">or_insert_with</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>
                <span class="token punctuation">(</span><span class="token class-name">HashSet</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token class-name">ClassUnicodeRange</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> confusable <span class="token keyword">in</span> confusables <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token operator">!</span>confusables_set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>confusable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                confusables_set<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>confusable<span class="token punctuation">)</span><span class="token punctuation">;</span>
                ranges<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">ClassUnicodeRange</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>confusable<span class="token punctuation">,</span> confusable<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/// Retrieve confusable characters related to an ascii character c</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_confusables_data</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> <span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">ClassUnicodeRange</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">let</span> confusables_data <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>confusables<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> ranges<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> confusables_data<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> ranges<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// The Map that gets accessed</span>
<span class="token keyword">pub</span> <span class="token keyword">static</span> <span class="token constant">HIR_CONFUSABLES_MAP</span><span class="token punctuation">:</span> <span class="token class-name">LazyLock</span><span class="token operator">&lt;</span><span class="token class-name">HirConfusables</span><span class="token operator">></span> <span class="token operator">=</span>
    <span class="token class-name">LazyLock</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">-></span> <span class="token class-name">HirConfusables</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">let</span> confusables <span class="token operator">=</span> <span class="token class-name">HirConfusables</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        confusables<span class="token punctuation">.</span><span class="token function">add_confusables</span><span class="token punctuation">(</span>
            <span class="token char">'a'</span><span class="token punctuation">,</span>
            <span class="token macro property">vec!</span><span class="token punctuation">[</span>
                <span class="token char">'…ë'</span><span class="token punctuation">,</span> <span class="token char">'ÔΩÅ'</span><span class="token punctuation">,</span> 'ùêö'<span class="token punctuation">,</span> 'ùëé'<span class="token punctuation">,</span> 'ùíÇ'<span class="token punctuation">,</span> 'ùí∂'<span class="token punctuation">,</span> 'ùì™'<span class="token punctuation">,</span> 'ùîû'<span class="token punctuation">,</span> 'ùïí'<span class="token punctuation">,</span> 'ùñÜ'<span class="token punctuation">,</span>
                'ùñ∫'<span class="token punctuation">,</span> 'ùóÆ'<span class="token punctuation">,</span> 'ùò¢'<span class="token punctuation">,</span> 'ùôñ'<span class="token punctuation">,</span> 'ùöä'<span class="token punctuation">,</span>
            <span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
        confusables
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ...</span>
<span class="token keyword">impl</span> <span class="token class-name">Hir</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
    <span class="token attribute attr-name">#[inline]</span>
    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">literal</span><span class="token operator">&lt;</span><span class="token class-name">B</span><span class="token punctuation">:</span> <span class="token class-name">Into</span><span class="token operator">&lt;</span><span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token keyword">u8</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">(</span>lit<span class="token punctuation">:</span> <span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Hir</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">let</span> bytes <span class="token operator">=</span> lit<span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> bytes<span class="token punctuation">.</span><span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token class-name">Hir</span><span class="token punctuation">::</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// If the literal is a single character, it is ascii: check for confusables</span>
        <span class="token keyword">if</span> bytes<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">let</span> character <span class="token operator">=</span> bytes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">char</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> confusables_data <span class="token operator">=</span>
                <span class="token constant">HIR_CONFUSABLES_MAP</span><span class="token punctuation">.</span><span class="token function">get_confusables_data</span><span class="token punctuation">(</span>character<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> confusables_data<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">Hir</span><span class="token punctuation">::</span><span class="token function">class</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token punctuation">::</span><span class="token class-name">Unicode</span><span class="token punctuation">(</span>
                    <span class="token class-name">ClassUnicode</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>confusables_data<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">)</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">let</span> lit <span class="token operator">=</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">let</span> props <span class="token operator">=</span> <span class="token class-name">Properties</span><span class="token punctuation">::</span><span class="token function">literal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lit<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Hir</span> <span class="token punctuation">&#123;</span> kind<span class="token punctuation">:</span> <span class="token class-name">HirKind</span><span class="token punctuation">::</span><span class="token class-name">Literal</span><span class="token punctuation">(</span>lit<span class="token punctuation">)</span><span class="token punctuation">,</span> props <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">let</span> lit <span class="token operator">=</span> <span class="token class-name">Literal</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">let</span> props <span class="token operator">=</span> <span class="token class-name">Properties</span><span class="token punctuation">::</span><span class="token function">literal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lit<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Hir</span> <span class="token punctuation">&#123;</span> kind<span class="token punctuation">:</span> <span class="token class-name">HirKind</span><span class="token punctuation">::</span><span class="token class-name">Literal</span><span class="token punctuation">(</span>lit<span class="token punctuation">)</span><span class="token punctuation">,</span> props <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span></code>`,on,A,Sn=`All test cases continue to pass with <code>cargo test</code> for the whole <code>regex</code> crate, and outputs also showed
that the alternations were being generated correctly with additional tests &amp; debug outputs.`,pn,S,zn='With this, we have an implementation that generates the HIR as desired, and the top level <a href="https://docs.rs/regex-automata/latest/regex_automata/meta/struct.Builder.html#method.build_from_hir" rel="nofollow">build_from_hir(&amp;self, hir: &amp;Hir)</a> function from <code>meta::Regex</code> can directly take the tree and build the automata, knowing that the <code>regex-automata</code> implementation will optimize it even further with a hybrid mix of Aho-Corasick and other strategies. By default, the <code>regex</code> crate already couples <code>regex-syntax</code> and <code>regex-automata</code> together for us, so no additional changes need to be made on that front.',cn,z,Un="Conclusion",ln,U,qn="This was pretty fun! Being forced to dig through various regex libraries and arxiv papers, I learned a lot more about how regex engines parse and optimize regex expressions. Also glad to have gotten to write a bit of Rust, albiet it‚Äôs being simple. Looking forward to more Rust & compilers in the future!";return{c(){i=e("p"),i.textContent=rn,q=p(),u=e("h2"),u.textContent=kn,E=p(),r=e("p"),r.innerHTML=hn,B=p(),k=e("p"),k.innerHTML=dn,D=p(),h=e("h2"),h.textContent=fn,F=p(),d=e("p"),d.innerHTML=mn,j=p(),f=e("p"),f.textContent=wn,O=p(),m=e("p"),m.innerHTML=bn,N=p(),w=e("ul"),w.innerHTML=yn,W=p(),b=e("h2"),b.textContent=gn,V=p(),y=e("h3"),y.textContent=xn,K=p(),g=e("p"),g.innerHTML=vn,Z=p(),x=e("p"),x.textContent=Cn,$=p(),v=e("ul"),v.innerHTML=Hn,G=p(),C=e("h3"),C.textContent=_n,J=p(),H=e("p"),H.innerHTML=Ln,Q=p(),_=e("p"),_.innerHTML=Tn,X=p(),L=e("p"),L.innerHTML=Mn,Y=p(),T=e("h2"),T.textContent=In,nn=p(),M=e("p"),M.innerHTML=Pn,sn=p(),I=e("p"),I.innerHTML=Rn,an=p(),P=e("p"),P.textContent=An,tn=p(),R=e("pre"),en=new On(!1),on=p(),A=e("p"),A.innerHTML=Sn,pn=p(),S=e("p"),S.innerHTML=zn,cn=p(),z=e("h2"),z.textContent=Un,ln=p(),U=e("p"),U.textContent=qn,this.h()},l(n){i=o(n,"P",{"data-svelte-h":!0}),c(i)!=="svelte-ds2zk5"&&(i.textContent=rn),q=l(n),u=o(n,"H2",{"data-svelte-h":!0}),c(u)!=="svelte-19vexm6"&&(u.textContent=kn),E=l(n),r=o(n,"P",{"data-svelte-h":!0}),c(r)!=="svelte-1h7aw26"&&(r.innerHTML=hn),B=l(n),k=o(n,"P",{"data-svelte-h":!0}),c(k)!=="svelte-n03qkp"&&(k.innerHTML=dn),D=l(n),h=o(n,"H2",{"data-svelte-h":!0}),c(h)!=="svelte-qy2ocb"&&(h.textContent=fn),F=l(n),d=o(n,"P",{"data-svelte-h":!0}),c(d)!=="svelte-17et4i3"&&(d.innerHTML=mn),j=l(n),f=o(n,"P",{"data-svelte-h":!0}),c(f)!=="svelte-1wmqtz5"&&(f.textContent=wn),O=l(n),m=o(n,"P",{"data-svelte-h":!0}),c(m)!=="svelte-sj5h81"&&(m.innerHTML=bn),N=l(n),w=o(n,"UL",{"data-svelte-h":!0}),c(w)!=="svelte-ww6zyg"&&(w.innerHTML=yn),W=l(n),b=o(n,"H2",{"data-svelte-h":!0}),c(b)!=="svelte-1ihqk6f"&&(b.textContent=gn),V=l(n),y=o(n,"H3",{"data-svelte-h":!0}),c(y)!=="svelte-n9ut1g"&&(y.textContent=xn),K=l(n),g=o(n,"P",{"data-svelte-h":!0}),c(g)!=="svelte-87gdfn"&&(g.innerHTML=vn),Z=l(n),x=o(n,"P",{"data-svelte-h":!0}),c(x)!=="svelte-inp1i0"&&(x.textContent=Cn),$=l(n),v=o(n,"UL",{"data-svelte-h":!0}),c(v)!=="svelte-vy02q6"&&(v.innerHTML=Hn),G=l(n),C=o(n,"H3",{"data-svelte-h":!0}),c(C)!=="svelte-9ra2bq"&&(C.textContent=_n),J=l(n),H=o(n,"P",{"data-svelte-h":!0}),c(H)!=="svelte-8317pb"&&(H.innerHTML=Ln),Q=l(n),_=o(n,"P",{"data-svelte-h":!0}),c(_)!=="svelte-1op85tr"&&(_.innerHTML=Tn),X=l(n),L=o(n,"P",{"data-svelte-h":!0}),c(L)!=="svelte-126iiv7"&&(L.innerHTML=Mn),Y=l(n),T=o(n,"H2",{"data-svelte-h":!0}),c(T)!=="svelte-63ryc"&&(T.textContent=In),nn=l(n),M=o(n,"P",{"data-svelte-h":!0}),c(M)!=="svelte-1iyy1yh"&&(M.innerHTML=Pn),sn=l(n),I=o(n,"P",{"data-svelte-h":!0}),c(I)!=="svelte-73g5qn"&&(I.innerHTML=Rn),an=l(n),P=o(n,"P",{"data-svelte-h":!0}),c(P)!=="svelte-118fmbq"&&(P.textContent=An),tn=l(n),R=o(n,"PRE",{class:!0});var s=Nn(R);en=Wn(s,!1),s.forEach(a),on=l(n),A=o(n,"P",{"data-svelte-h":!0}),c(A)!=="svelte-mtlibd"&&(A.innerHTML=Sn),pn=l(n),S=o(n,"P",{"data-svelte-h":!0}),c(S)!=="svelte-iu1fmo"&&(S.innerHTML=zn),cn=l(n),z=o(n,"H2",{"data-svelte-h":!0}),c(z)!=="svelte-grw4hp"&&(z.textContent=Un),ln=l(n),U=o(n,"P",{"data-svelte-h":!0}),c(U)!=="svelte-15k7fha"&&(U.textContent=qn),this.h()},h(){en.a=null,Vn(R,"class","language-rust")},m(n,s){t(n,i,s),t(n,q,s),t(n,u,s),t(n,E,s),t(n,r,s),t(n,B,s),t(n,k,s),t(n,D,s),t(n,h,s),t(n,F,s),t(n,d,s),t(n,j,s),t(n,f,s),t(n,O,s),t(n,m,s),t(n,N,s),t(n,w,s),t(n,W,s),t(n,b,s),t(n,V,s),t(n,y,s),t(n,K,s),t(n,g,s),t(n,Z,s),t(n,x,s),t(n,$,s),t(n,v,s),t(n,G,s),t(n,C,s),t(n,J,s),t(n,H,s),t(n,Q,s),t(n,_,s),t(n,X,s),t(n,L,s),t(n,Y,s),t(n,T,s),t(n,nn,s),t(n,M,s),t(n,sn,s),t(n,I,s),t(n,an,s),t(n,P,s),t(n,tn,s),t(n,R,s),en.m(Bn,R),t(n,on,s),t(n,A,s),t(n,pn,s),t(n,S,s),t(n,cn,s),t(n,z,s),t(n,ln,s),t(n,U,s)},p:un,i:un,o:un,d(n){n&&(a(i),a(q),a(u),a(E),a(r),a(B),a(k),a(D),a(h),a(F),a(d),a(j),a(f),a(O),a(m),a(N),a(w),a(W),a(b),a(V),a(y),a(K),a(g),a(Z),a(x),a($),a(v),a(G),a(C),a(J),a(H),a(Q),a(_),a(X),a(L),a(Y),a(T),a(nn),a(M),a(sn),a(I),a(an),a(P),a(tn),a(R),a(on),a(A),a(pn),a(S),a(cn),a(z),a(ln),a(U))}}}const Gn={title:"A Stroll into the RegEx Trees",date:"2024-08-29"};class Jn extends Fn{constructor(i){super(),jn(this,i,null,Kn,Dn,{})}}export{Jn as default,Gn as metadata};
